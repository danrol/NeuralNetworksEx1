import numpy as np
import tensorflow as tf


def build_xor_neural_network(matrix_data, k, bypass, w1, w2, hidden_layer_biases, output_neuron_bias):
    amount_input_neurons = 2
    amount_output_neurons = 1
    t = 0.001

    x = tf.compat.v1.placeholder(tf.float32, [None, amount_input_neurons])
    y = tf.compat.v1.placeholder(tf.float32, [None, amount_output_neurons])

    w1 = tf.Variable(w1.reshape([amount_input_neurons, k]), dtype=tf.float32)

    w2 = tf.Variable(w2.reshape([k, amount_output_neurons]), dtype=tf.float32)

    b1 = tf.Variable(hidden_layer_biases, dtype=tf.float32)
    b2 = tf.Variable(output_neuron_bias, dtype=tf.float32)

    hidden_layer_neurons_result = tf.sigmoid((tf.matmul(x, w1) +b1)/t)

    output_neuron_result = tf.sigmoid((tf.matmul(hidden_layer_neurons_result, w2)+b2)/t)
    loss = tf.reduce_all(tf.square(output_neuron_result - y))

    session = tf.compat.v1.Session()
    var = tf.compat.v1.global_variables_initializer()
    session.run(var)
    return session.run([output_neuron_result, loss])



if __name__ == '__main__':
    train_data_set = [[0, 0], [1, 0], [0, 1], [1, 1]]
    expected_result = []

    k = 4
    w1 = np.array([-1, -1, 1, 1, -1, 1, -1, 1])
    w2 = np.array([-1, 1, 1, -1])
    biases = [-0.5, 0.5, 0.5, -2.5]
    output_neuron_bias = -0.5
    bypass = False
    print(f'k = {k} \nweights between inputs to hidden layer = {w1}\nweights between hidden layer to output layer = {w2}'
          f'\nhidden layer biases = {biases}\noutput layer bias = {output_neuron_bias}')

    (truth_table_result, avg_square_error) = build_xor_neural_network(train_data_set, k, bypass, w1, w2, biases, output_neuron_bias)

